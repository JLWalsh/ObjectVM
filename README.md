## OVM (Object virtual machine)
An object-oriented bytecode virtual machine, inspired by the JVM.

### Example program
Suppose the class B is represented as:
```java
class B {

    private unsigned int a;

    public B(unsigned int a) {
        this.a = a;
    }

    doPrint() {
        print(this.a);
    }
}
```


```
// Main (this = NULL)
OP_NEW, 0,     // Create new object with ID 0 (class B), pushes reference to object onto the stack
OP_DUP,        // Duplicate the reference
OP_UI_PUSH, 2, // Push 2 as unsigned integer onto the stack
OP_INVOKE, 0, 0, 1, // Invoke B::new(int) with 1 arg (the number 2). This consumes the duplicated reference
OP_INVOKE, 0, 1, 0, // Invoke B::doPrint with 0 args. This consumes the reference generated by OP_NEW
OP_HALT, // Halt

// B::new(int)
// this = some instance of B
OP_LOCAL_LOAD, 0,      // Load function arg (the value from OP_UI_PUSH) onto the stack. We know it's at offset 0 because this method only contains 1 argument
OP_UI_GLOBAL_STORE, 0, // Store said argument as A. This operation is bound to the "this" variable, which the VM automatically updates when using OP_INVOKE
OP_RETURN_VOID, // Return control back to the instruction after OP_INVOKE

// B::doPrint
// this = some instance of B
OP_UI_GLOBAL_LOAD, 0, // Load A as int from B's private variable A. Note that this operation is also bound to the "this" variable.
OP_UI_PRINT, // Print it. This consumes the value.
OP_RETURN_VOID // Return control back to the instruction after the second OP_INVOKE
```

### Notes
- All numeric values are represented in the big endian format


### Short-term TODOs

- Heap automatic resize
- Properly implement flags in ovmmemory