## OVM (Object virtual machine)
[![Build Status](https://travis-ci.org/JLWalsh/ObjectVM.svg?branch=master)](https://travis-ci.org/JLWalsh/ObjectVM)

An object-oriented bytecode virtual machine, inspired by the JVM.

### Roadmap
Since this is a fairly big project to undertake, this project has been split into a couple parts:

1. Finalize object mechanics. 
    - Includes figuring out inheritance, interfaces, etc. For now, context binding (this) works!
2. Implement automatic memory management. 
    - Includes a mark and sweep GC, memory compaction (to prevent fragmentation), and automatic reference updating (due to the VM moving objects around in memory).
3. Bytecode parsing.
    - The VM needs to be able to load a program from a file in order to be remotely useful!
    - As of now, the VM only knows about certain objects declared in code. Eventually, the VM will need to be able to load objects from a file instead, similar to what the JVM does with .class files. 
4. More instructions.
    - Native string support
    - Instructions to perform operations on ints, floats, etc.
    - More types: ints, floats, strings, longs, ulongs, etc.

### Example program
Suppose the class B is represented as (java):
```java
class B {

    private unsigned int a;

    public B(unsigned int a) {
        this.a = a;
    }

    doPrint() {
        print(this.a);
    }
}
```

Then the corresponding program for ObjectVM would be:

```
// Main (this = NULL)
OP_NEW, 0,     // Create new object with ID 0 (class B), pushes reference to object onto the stack
OP_DUP,        // Duplicate the reference
OP_UI_PUSH, 2, // Push 2 as unsigned integer onto the stack
OP_INVOKE, 0, 0, 1, // Invoke B::new(int) with 1 arg (the number 2). This consumes the duplicated reference
OP_INVOKE, 0, 1, 0, // Invoke B::doPrint with 0 args. This consumes the reference generated by OP_NEW
OP_HALT, // Halt

// B::new(int)
// this = some instance of B
OP_LOCAL_LOAD, 0,      // Load function arg (the value from OP_UI_PUSH) onto the stack. We know it's at offset 0 because this method only contains 1 argument
OP_UI_GLOBAL_STORE, 0, // Store said argument as A. This operation is bound to the "this" variable, which the VM automatically updates when using OP_INVOKE
OP_RETURN_VOID, // Return control back to the instruction after OP_INVOKE

// B::doPrint
// this = some instance of B
OP_UI_GLOBAL_LOAD, 0, // Load A as int from B's private variable A. Note that this operation is also bound to the "this" variable.
OP_UI_PRINT, // Print it. This consumes the value.
OP_RETURN_VOID // Return control back to the instruction after the second OP_INVOKE
```

### Notes
- All numeric values are represented in the big endian format


### Short-term TODOs

* [ ] Heap automatic resize
* [ ] Properly implement flags in omemory
